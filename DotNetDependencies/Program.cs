/* 
Использование семантического управления версиями(!).

Существует отраслевой стандарт, который называется семантическим управлением версиями. Семантическое управление версиями — это способ показать, какого рода изменения вы или какой-то другой разработчик вносите в библиотеку. Семантическое управление версиями обеспечивает каждый пакет номером версии, состоящим из следующих разделов.

    Основной номер версии. Крайняя слева цифра. Например, это 1 в 1.0.0. Изменение этой цифры указывает на критические изменения в коде. Возможно, часть кода придется переписать.
    Дополнительный номер версии. Средняя цифра. Например, это 2 в 1.2.0. Изменение этой цифры означает, что были добавлены какие-то функции. Код должен работать, как и раньше. Такое обновление обычно безопасно.
    Версия исправления. Крайняя справа цифра. Например, это 3 в 1.2.3. Изменение этой цифры означает, что в код внесли исправления, которые должны работать. Такое обновление должно быть безопасным.
******************************************************************

Метод обновления

Как разработчик, вы можете сообщить .NET, какое поведение обновления требуется. При обновлении в первую очередь следует учитывать риск. Вот несколько подходов:

    Основной номер версии. Обновление до последней основной версии можно установить, как только оно будет выпущено. Я принимаю тот факт, что мне может потребоваться изменить код со своей стороны.
    Дополнительный номер версии. Добавление новой функции меня устраивает. Меня не устраивает только нарушение работы кода.
    Версия исправления. Единственные обновления, которые меня устраивают, — это исправления ошибок.
***********************************************************************

Notation 	Примененное правило 	Описание
1.0 	x >= 1,0 	Минимальная версия, включающая
(1.0,) 	x > 1.0 	Минимальная версия, исключающая
[1.0] 	x == 1.0 	Точное соответствие версии
(,1.0] 	x ≤ 1.0 	Максимальная версия, включающая
(,1.0) 	x < 1.0 	Максимальная версия, исключающая
[1.0,2.0] 	1.0 ≤ x ≤ 2.0 	Точный диапазон, включающий
(1.0,2.0) 	1.0 < x < 2.0 	Точный диапазон, исключающий
[1.0,2.0) 	1.0 ≤ x < 2.0 	Смешанная включающая минимальная и исключающая максимальная версии
(1.0) 	недопустимо 	недопустимо

Эти команды рекомендуется выполнять в следующем порядке:

    Выполните команду dotnet list package --outdated. Она выводит список всех устаревших пакетов. Сведения возвращаются в столбцах Requested, Resolved и Latest.
    Выполните команду dotnet add package <package name>. При выполнении этой команды будет предпринята попытка обновления до последней версии. При необходимости вы можете передать --version=<version number/range>.











*/


// using Humanizer;

// Console.WriteLine("Quantities:");
// HumanizeQuantities();

// Console.WriteLine("\nDate/Time Manipulation:");
// HumanizeDates();

// static void HumanizeQuantities()
// {
//     Console.WriteLine("case".ToQuantity(0));
//     Console.WriteLine("case".ToQuantity(1));
//     Console.WriteLine("case".ToQuantity(5));
// }

// static void HumanizeDates()
// {
//     Console.WriteLine(DateTime.UtcNow.AddHours(-24).Humanize());
//     Console.WriteLine(DateTime.UtcNow.AddHours(-2).Humanize());
//     Console.WriteLine(TimeSpan.FromDays(1).Humanize());
//     Console.WriteLine(TimeSpan.FromDays(16).Humanize());
// }
// ****************************************************************************

// 0 (0), 1 (1), 1 (2), 2 (3), 3 (4), 5 (5), 8 (6), 13 (7), 21 (8)...

using System.Diagnostics;

int result = Fibonacci(6);
Console.WriteLine(result);

static int Fibonacci(int n)
{
    Debug.WriteLine($"Entering {nameof(Fibonacci)} method");
    Debug.WriteLine($"We are looking for the {n}th number");
    
    int n1 = 0;
    int n2 = 1;
    int sum;

    for (int i = 2; i <= n; i++)
    {
        sum = n1 + n2;
        n1 = n2;
        n2 = sum;
       Debug.WriteLineIf(sum == 1, $"sum is 1, n1 is {n1}, n2 is {n2}"); 
    }
        // If n2 is 5 continue, else break.
        Debug.Assert(n2 == 5, "The return value is not 5 and it should be.");
        return n == 0 ? n1 : n2;

    return n == 0 ? n1 : n2;
}